// learnjq — Quick Reference
// Searchable cheat sheet of all jq builtins, operators, and flags.
// Organized by category: basics, types, strings, arrays, objects, etc.
const REFERENCE = [
  {
    title: "Basics",
    items: [
      { syntax: ".", desc: "Identity — pass input unchanged" },
      { syntax: ".foo", desc: "Object field access" },
      { syntax: ".foo.bar", desc: "Nested field access" },
      { syntax: ".foo?", desc: "Optional field (no error if missing)" },
      { syntax: ".[0]", desc: "Array index (0-based)" },
      { syntax: ".[-1]", desc: "Last element" },
      { syntax: ".[2:5]", desc: "Array slice (start:end, exclusive)" },
      { syntax: ".[]", desc: "Iterate all elements" },
      { syntax: ".[]?", desc: "Iterate (no error if not iterable)" },
      { syntax: "|", desc: "Pipe — chain filters" },
      { syntax: ",", desc: "Output multiple values" },
    ]
  },
  {
    title: "Types & Values",
    items: [
      { syntax: "null, true, false", desc: "Literal values" },
      { syntax: "type", desc: "Get type as string" },
      { syntax: "length", desc: "String chars, array elements, object keys" },
      { syntax: "utf8bytelength", desc: "Byte length of string" },
      { syntax: "keys", desc: "Object keys (sorted)" },
      { syntax: "keys_unsorted", desc: "Object keys (original order)" },
      { syntax: "values", desc: "Object values" },
      { syntax: 'has("key")', desc: "Check if key exists" },
      { syntax: 'in(obj)', desc: "Check if string is key in object" },
      { syntax: "contains(b)", desc: "Check if a contains b" },
      { syntax: "inside(b)", desc: "Check if a is inside b" },
      { syntax: "empty", desc: "Produce no output" },
      { syntax: "error(msg)", desc: "Raise an error" },
      { syntax: "builtins", desc: "List all builtin functions" },
      { syntax: "input", desc: "Read next input" },
      { syntax: "debug", desc: "Print to stderr, pass through" },
      { syntax: "debug(msg)", desc: "Print labeled debug" },
    ]
  },
  {
    title: "Strings",
    items: [
      { syntax: '"Hello \\(.name)"', desc: "String interpolation" },
      { syntax: "tostring", desc: "Convert to string" },
      { syntax: "tonumber", desc: "Convert to number" },
      { syntax: "ascii_downcase", desc: "Lowercase" },
      { syntax: "ascii_upcase", desc: "Uppercase" },
      { syntax: 'ltrimstr("pre")', desc: "Remove prefix" },
      { syntax: 'rtrimstr("suf")', desc: "Remove suffix" },
      { syntax: 'startswith("pre")', desc: "Check prefix" },
      { syntax: 'endswith("suf")', desc: "Check suffix" },
      { syntax: 'split(",")', desc: "Split string into array" },
      { syntax: 'join("-")', desc: "Join array into string" },
      { syntax: 'test("regex")', desc: "Regex match test (boolean)" },
      { syntax: 'test("re"; "i")', desc: "Case-insensitive regex" },
      { syntax: 'match("regex")', desc: "Regex match details" },
      { syntax: 'capture("(?<n>\\\\w+)")', desc: "Named captures as object" },
      { syntax: 'scan("\\\\d+")', desc: "All regex matches as array" },
      { syntax: 'sub("old"; "new")', desc: "Replace first match" },
      { syntax: 'gsub("old"; "new")', desc: "Replace all matches" },
      { syntax: "explode", desc: "String → array of codepoints" },
      { syntax: "implode", desc: "Array of codepoints → string" },
    ]
  },
  {
    title: "Arrays",
    items: [
      { syntax: "[expr]", desc: "Collect outputs into array" },
      { syntax: "map(f)", desc: "Apply f to each element: [.[] | f]" },
      { syntax: "map_values(f)", desc: "Apply f to each value (objects too)" },
      { syntax: "select(cond)", desc: "Keep if condition true" },
      { syntax: "empty", desc: "Produce no output (use in select)" },
      { syntax: "sort", desc: "Sort array" },
      { syntax: "sort_by(.f)", desc: "Sort by field" },
      { syntax: "reverse", desc: "Reverse array" },
      { syntax: "group_by(.f)", desc: "Group into sub-arrays by field" },
      { syntax: "unique", desc: "Remove duplicates (sorts)" },
      { syntax: "unique_by(.f)", desc: "Unique by field" },
      { syntax: "flatten", desc: "Flatten nested arrays" },
      { syntax: "flatten(n)", desc: "Flatten n levels deep" },
      { syntax: "min, max", desc: "Minimum/maximum value" },
      { syntax: "min_by(.f), max_by(.f)", desc: "Min/max by field" },
      { syntax: "add", desc: "Sum numbers, concat strings/arrays" },
      { syntax: "any, all", desc: "Any/all truthy" },
      { syntax: "any(cond), all(cond)", desc: "Any/all matching condition" },
      { syntax: "first(expr)", desc: "First output of expression" },
      { syntax: "last(expr)", desc: "Last output of expression" },
      { syntax: "nth(n; expr)", desc: "Nth output" },
      { syntax: "limit(n; expr)", desc: "First n outputs" },
      { syntax: "range(n)", desc: "0 to n-1" },
      { syntax: "range(a; b)", desc: "a to b-1" },
      { syntax: "range(a; b; s)", desc: "a to b-1 step s" },
      { syntax: "indices(val)", desc: "All indices where val appears" },
      { syntax: "index(val)", desc: "First index of val" },
      { syntax: "rindex(val)", desc: "Last index of val" },
      { syntax: "transpose", desc: "Transpose 2D array" },
      { syntax: "input, inputs", desc: "Read from stdin" },
    ]
  },
  {
    title: "Objects",
    items: [
      { syntax: "{name, age}", desc: "Select fields (shorthand)" },
      { syntax: '{n: .name}', desc: "Rename fields" },
      { syntax: "{(.k): .v}", desc: "Dynamic key" },
      { syntax: "to_entries", desc: 'Object → [{key,value},...]' },
      { syntax: "from_entries", desc: '[{key,value},...] → object' },
      { syntax: "with_entries(f)", desc: "to_entries | map(f) | from_entries" },
      { syntax: "a + b", desc: "Merge objects (right wins)" },
      { syntax: "a * b", desc: "Deep/recursive merge" },
      { syntax: "del(.foo)", desc: "Delete field" },
      { syntax: "getpath(p)", desc: "Get value at path array" },
      { syntax: "setpath(p; v)", desc: "Set value at path" },
      { syntax: "delpaths([p])", desc: "Delete paths" },
    ]
  },
  {
    title: "Conditionals & Logic",
    items: [
      { syntax: "if C then T else F end", desc: "Conditional (else required)" },
      { syntax: "if C then T elif C2 then T2 else F end", desc: "Multi-branch" },
      { syntax: "//", desc: "Alternative (default for null/false)" },
      { syntax: "not", desc: "Boolean negation" },
      { syntax: "and, or", desc: "Boolean operators" },
      { syntax: "==, !=, <, >, <=, >=", desc: "Comparison" },
      { syntax: "try E", desc: "Suppress errors" },
      { syntax: "try E catch C", desc: "Handle errors (. = message)" },
      { syntax: "?//", desc: "Try alternative" },
    ]
  },
  {
    title: "Update Operators",
    items: [
      { syntax: ".f |= g", desc: "Update .f by applying g" },
      { syntax: ".f = v", desc: "Set .f to value" },
      { syntax: ".f += v", desc: "Add to .f" },
      { syntax: ".f -= v", desc: "Subtract from .f" },
      { syntax: ".f *= v", desc: "Multiply .f" },
      { syntax: ".f /= v", desc: "Divide .f" },
      { syntax: ".f %= v", desc: "Modulo .f" },
    ]
  },
  {
    title: "Variables, Functions, Reduce",
    items: [
      { syntax: "expr as $x | ...", desc: "Bind to variable" },
      { syntax: ". as {a: $a} | ...", desc: "Destructure object" },
      { syntax: ". as [$a, $b] | ...", desc: "Destructure array" },
      { syntax: "def name: body;", desc: "Define function" },
      { syntax: "def name(a; b): body;", desc: "Function with params" },
      { syntax: "reduce .[] as $x (init; update)", desc: "Fold/accumulate" },
      { syntax: "foreach .[] as $x (init; update; extract)", desc: "Running accumulation" },
      { syntax: "label $out | ... break $out", desc: "Early exit from foreach" },
      { syntax: "until(cond; update)", desc: "Loop until condition" },
      { syntax: "while(cond; update)", desc: "Loop while condition" },
      { syntax: "repeat(f)", desc: "Infinite loop (use with limit)" },
    ]
  },
  {
    title: "Advanced & I/O",
    items: [
      { syntax: "..", desc: "Recursive descent (all values)" },
      { syntax: "recurse(f)", desc: "Recursive descent with filter" },
      { syntax: "recurse(f; cond)", desc: "Recursive with condition" },
      { syntax: "path(expr)", desc: "Path to value as array" },
      { syntax: "paths", desc: "All paths" },
      { syntax: "paths(filter)", desc: "Paths matching filter" },
      { syntax: "leaf_paths", desc: "Paths to leaf values" },
      { syntax: "getpath(p)", desc: "Value at path" },
      { syntax: "setpath(p; v)", desc: "Set value at path" },
      { syntax: "tostream", desc: "Convert to path-value stream" },
      { syntax: "fromstream(s)", desc: "Reconstruct from stream" },
      { syntax: "env, $ENV", desc: "Environment variables" },
      { syntax: "INDEX(f)", desc: "Build lookup by f" },
      { syntax: "INDEX(s; f)", desc: "Index stream by f" },
      { syntax: "IN(s)", desc: "Check membership" },
      { syntax: "limit(n; f)", desc: "First n outputs" },
      { syntax: "isempty(f)", desc: "True if f produces nothing" },
      { syntax: "isnan, isinfinite, nan, infinite", desc: "Special number checks" },
    ]
  },
  {
    title: "Format Strings",
    items: [
      { syntax: "@base64", desc: "Base64 encode" },
      { syntax: "@base64d", desc: "Base64 decode" },
      { syntax: "@csv", desc: "CSV format (array → line)" },
      { syntax: "@tsv", desc: "Tab-separated values" },
      { syntax: "@html", desc: "HTML entity encode" },
      { syntax: "@uri", desc: "URL/percent encode" },
      { syntax: "@json", desc: "JSON encode (as string)" },
      { syntax: "@text", desc: "Plain text" },
    ]
  },
  {
    title: "Command-Line Flags",
    items: [
      { syntax: "-r", desc: "Raw output (no quotes on strings)" },
      { syntax: "-R", desc: "Raw input (read lines as strings)" },
      { syntax: "-s", desc: "Slurp (read all inputs into array)" },
      { syntax: "-n", desc: "Null input (don't read stdin)" },
      { syntax: "-e", desc: "Exit with error if output is null/false" },
      { syntax: "-c", desc: "Compact output (no pretty-print)" },
      { syntax: "-S", desc: "Sort object keys" },
      { syntax: "--tab", desc: "Use tabs for indentation" },
      { syntax: "--indent N", desc: "Set indent width" },
      { syntax: "--arg name val", desc: "Set $name to string val" },
      { syntax: "--argjson name val", desc: "Set $name to JSON val" },
      { syntax: "--slurpfile name file", desc: "Set $name to file contents" },
      { syntax: "--rawfile name file", desc: "Set $name to raw file string" },
      { syntax: "--jsonargs", desc: "Remaining args are JSON" },
    ]
  }
];
